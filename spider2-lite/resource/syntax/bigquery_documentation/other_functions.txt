Send feedback

#  Other functions

This category introduces some common functions, operators, syntax, expressions or statements that are very popular in Google BigQuery.


###  Function list

Name  |  Summary
---|---
` CREATE_FUNCTION ` |  Creates a new user-defined function (UDF). BigQuery supports UDFs written in either SQL or JavaScript.
` DECLARE ` |  Declares a variable of the specified type.
` SET ` |  Sets a variable to have the value of the provided expression.
` UNNEST ` |  Takes an array and returns a table with one row for each element in the array.
` PIVOT ` |  Rotates rows into columns, using aggregation.
` UNPIVOT ` |  Rotates columns into rows.
` TABLESAMPLE ` |  Select a random sample of a dataset.
` ARRAY_SUBSCRIPT ` |  Gets a value from an array at a specific position.
` STRUCT_SUBSCRIPT ` |  Gets the value of a field at a selected position in a struct.



###  ` CREATE_FUNCTION `

Creates a new [ user-defined function ](/bigquery/docs/user-defined-functions)
(UDF). BigQuery supports UDFs written in either SQL or JavaScript.

####  Syntax

To create a SQL UDF, use the following syntax:



CREATE [ OR REPLACE ] [ TEMPORARY | TEMP ] FUNCTION [ IF NOT EXISTS ]
[[project_name.]dataset_name.]function_name
([named_parameter[, ...]])
([named_parameter[, ...]])
[RETURNS data_type]
AS (sql_expression)
[OPTIONS (function_option_list)]

named_parameter:
param_name param_type


To create a JavaScript UDF, use the following syntax:



CREATE [OR REPLACE] [TEMPORARY | TEMP] FUNCTION [IF NOT EXISTS]
[[project_name.]dataset_name.]function_name
([named_parameter[, ...]])
RETURNS data_type
[determinism_specifier]
LANGUAGE js
[OPTIONS (function_option_list)]
AS javascript_code

named_parameter:
param_name param_type

determinism_specifier:
{ DETERMINISTIC | NOT DETERMINISTIC }


To create a remote function, use the following syntax:



CREATE [OR REPLACE] FUNCTION [IF NOT EXISTS]
[[project_name.]dataset_name.]function_name
([named_parameter[, ...]])
RETURNS data_type
REMOTE WITH CONNECTION connection_path
[OPTIONS (function_option_list)]

named_parameter:
param_name param_type


Routine names must contain only letters, numbers, and underscores, and be at
most 256 characters long.

####  Arguments

* ` OR REPLACE ` : Replaces any function with the same name if it exists. Cannot appear with ` IF NOT EXISTS ` .

* ` IF NOT EXISTS ` : If any dataset exists with the same name, the ` CREATE ` statement has no effect. Cannot appear with ` OR REPLACE ` .

* ` TEMP ` or ` TEMPORARY ` : Creates a temporary function. If the clause is not present, the statement creates a persistent UDF. You can reuse persistent UDFs across multiple queries, whereas you can only use temporary UDFs in a single query, script, session, or procedure.

* ` project_name ` : For persistent functions, the name of the project where you are creating the function. Defaults to the project that runs the DDL query. Do not include the project name for temporary functions.

* ` dataset_name ` : For persistent functions, the name of the dataset where you are creating the function. Defaults to the ` defaultDataset ` in the request. Do not include the dataset name for temporary functions.

* ` function_name ` : The name of the function.

* ` named_parameter ` : A comma-separated ` param_name ` and ` param_type ` pair. The value of ` param_type ` is a BigQuery [ data type ](/bigquery/docs/reference/standard-sql/data-types) . For a SQL UDF, the value of ` param_type ` can also be ` ANY TYPE ` .

* ` determinism_specifier ` : Applies only to JavaScript UDFs. Provides a hint to BigQuery as to whether the query result can be cached. Can be one of the following values:

* ` DETERMINISTIC ` : The function always returns the same result when passed the same arguments. The query result is potentially cacheable. For example, if the function ` add_one(i) ` always returns ` i + 1 ` , the function is deterministic.

* ` NOT DETERMINISTIC ` : The function does not always return the same result when passed the same arguments, and therefore is not cacheable. For example, if the functionj ` add_random(i) ` returns ` i + rand() ` , the function is not deterministic and BigQuery does not use cached results.

If all of the invoked functions are ` DETERMINISTIC ` , BigQuery tries to
cache the result, unless the results can't be cached for other reasons. For
more information, see [ Using cached query results ](/bigquery/docs/cached-
results) .

* ` data_type ` : The data type that the function returns.

* If the function is defined in SQL, then the ` RETURNS ` clause is optional. If the ` RETURNS ` clause is omitted, then BigQuery infers the result type of the function from the SQL function body when a query calls the function.
* If the function is defined in JavaScript, then the ` RETURNS ` clause is required. For more information about allowed values for ` data_type ` , see [ Supported JavaScript UDF data types ](/bigquery/docs/reference/standard-sql/user-defined-functions#supported-javascript-udf-data-types) .
* ` sql_expression ` : The SQL expression that defines the function.

* ` function_option_list ` : A list of options for creating the function.

* ` javascript_code ` : The definition of a JavaScript function. The value is a [ string literal ](/bigquery/docs/reference/standard-sql/lexical#string_and_bytes_literals) . If the code includes quotes and backslashes, it must be either escaped or represented as a raw string. For example, the code ` return "\n"; ` can be represented as one of the following:

* Quoted string ` "return \"\\n\";" ` . Both quotes and backslashes need to be escaped.
* Triple quoted string: ` """return "\\n";""" ` . Backslashes need to be escaped while quotes do not.
* Raw string: ` r"""return "\n";""" ` . No escaping is needed.
* ` connection_name ` : Specifies a [ connection resource ](/bigquery/docs/connections-api-intro) that has credentials for accessing the remote endpoint. Specify the connection name in the form ` project_name.location.connection_id ` : If the project name or location contains a dash, enclose the connection name in backticks ( ` ` ` ).

####  ` function_option_list `

The option list specifies options for creating a UDF. The following options
are supported:

` NAME ` |  ` VALUE ` |  Details
---|---|---
` description ` |

` STRING `

|  A description of the UDF.
` library ` |

` ARRAY<STRING> `

|

An array of JavaScript libraries to include in the function definition.
Applies only to JavaScript UDFs. For more information, see [ Including
JavaScript libraries ](/bigquery/docs/user-defined-functions#including-
javascript-libraries) .

Example: ` ["gs://my-bucket/lib1.js", "gs://my-bucket/lib2.js"] `

` endpoint ` |

` STRING `

|

A HTTP endpoint of Cloud Functions. Applies only to remote functions.

Example: ` "https://us-east1-your-project.cloudfunctions.net/foo" `

For more information, see [ Creating a Remote Function
](/bigquery/docs/remote-functions#creating-remote-function) .

` user_defined_context ` |

` ARRAY<STRUCT<STRING,STRING>> `

|

A list of key-value pairs that will be sent with every HTTP request when the
function is invoked. Applies only to remote functions.

Example: ` [("key1","value1"),("key2", "value2")] `

` max_batching_rows ` |

` INT64 `

|

The maximum number of rows in each HTTP request. If not specified, BigQuery
decides how many rows are included in a HTTP request. Applies only to remote
functions.

####  Required permissions

This statement requires the following [ IAM permissions
](/bigquery/docs/access-control#bq-permissions) :

Permission  |  Resource
---|---
` bigquery.routines.create ` |  The dataset where you create the function.

In addition, the ` OR REPLACE ` clause requires ` bigquery.routines.update `
permission.

To create a remote function, additional [ IAM permissions
](/bigquery/docs/access-control#bq-permissions) are needed:

Permission  |  Resource
---|---
` bigquery.connections.delegate ` |  The connection which you use to create
the remote function.

####  Examples

####  Create a SQL UDF

The following example creates a persistent SQL UDF named ` multiplyInputs ` in
a dataset named ` mydataset ` .



CREATE FUNCTION mydataset.multiplyInputs(x FLOAT64, y FLOAT64)
RETURNS FLOAT64
AS (x * y);


####  Create a JavaScript UDF

The following example creates a temporary JavaScript UDF named `
multiplyInputs ` and calls it from inside a ` SELECT ` statement.



CREATE TEMP FUNCTION multiplyInputs(x FLOAT64, y FLOAT64)
RETURNS FLOAT64
LANGUAGE js
AS r"""
return x*y;
""";


SELECT multiplyInputs(a, b) FROM (SELECT 3 as a, 2 as b);


####  Create a remote function

The following example creates a persistent remote function named `
remoteMultiplyInputs ` in a dataset named ` mydataset ` , assuming ` mydataset
` is in ` US ` location and there is a connection ` myconnection ` in the same
location and same project.



CREATE FUNCTION mydataset.remoteMultiplyInputs(x FLOAT64, y FLOAT64)
RETURNS FLOAT64
REMOTE WITH CONNECTION us.myconnection
OPTIONS(endpoint="https://us-central1-myproject.cloudfunctions.net/multiply");



###  ` DECLARE `



DECLARE variable_name[, ...] [variable_type] [DEFAULT expression];


` variable_name ` must be a valid identifier, and ` variable_type ` is any
GoogleSQL [ type ](/bigquery/docs/reference/standard-sql/data-types) .

**Description**

Declares a variable of the specified type. If the ` DEFAULT ` clause is
specified, the variable is initialized with the value of the expression; if no
` DEFAULT ` clause is present, the variable is initialized with the value `
NULL ` .

If ` [variable_type] ` is omitted then a ` DEFAULT ` clause must be specified.
The variableâ€™s type will be inferred by the type of the expression in the `
DEFAULT ` clause.

Variable declarations must appear before other procedural statements, or at
the start of a ` BEGIN ` block. Variable names are case-insensitive.

Multiple variable names can appear in a single ` DECLARE ` statement, but only
one ` variable_type ` and ` expression ` .

It is an error to declare a variable with the same name as a variable declared
earlier in the current block or in a containing block.

If the ` DEFAULT ` clause is present, the value of the expression must be
coercible to the specified type. The expression may reference other variables
declared previously within the same block or a containing block.

GoogleSQL also supports [ system variables ](/bigquery/docs/reference/system-
variables) . You do not need to declare system variables, but you can set any
of them that are not marked read-only. You can reference system variables in
queries.

**Examples**

The following example initializes the variable ` x ` as an ` INT64 ` with the
value ` NULL ` .



DECLARE x INT64;


The following example initializes the variable ` d ` as a ` DATE ` object with
the value of the current date.



DECLARE d DATE DEFAULT CURRENT_DATE();


The following example initializes the variables ` x ` , ` y ` , and ` z ` as `
INT64 ` with the value 0.



DECLARE x, y, z INT64 DEFAULT 0;


The following example declares a variable named ` item ` corresponding to an
arbitrary item in the ` schema1.products ` table. The type of ` item ` is
inferred from the table schema.



DECLARE item DEFAULT (SELECT item FROM schema1.products LIMIT 1);


###  ` SET `

**Syntax**



SET variable_name = expression;



SET (variable_name[, ...]) = (expression[, ...]);


**Description**

Sets a variable to have the value of the provided expression, or sets multiple
variables at the same time based on the result of multiple expressions.

The ` SET ` statement may appear anywhere within a multi-statement query.

**Examples**

The following example sets the variable ` x ` to have the value 5.



SET x = 5;


The following example sets the variable ` a ` to have the value 4, ` b ` to
have the value 'foo', and the variable ` c ` to have the value ` false ` .



SET (a, b, c) = (1 + 3, 'foo', false);


The following example assigns the result of a query to multiple variables.
First, it declares two variables, ` target_word ` and ` corpus_count ` ; next,
it assigns the results of a [ ` SELECT AS STRUCT ` query
](/bigquery/docs/reference/standard-sql/query-syntax#select_modifiers) to the
two variables. The result of the query is a single row containing a ` STRUCT `
with two fields; the first element is assigned to the first variable, and the
second element is assigned to the second variable.



DECLARE target_word STRING DEFAULT 'methinks';
DECLARE corpus_count, word_count INT64;

SET (corpus_count, word_count) = (
SELECT AS STRUCT COUNT(DISTINCT corpus), SUM(word_count)
FROM bigquery-public-data.samples.shakespeare
WHERE LOWER(word) = target_word
);

SELECT
FORMAT('Found %d occurrences of "%s" across %d Shakespeare works',
word_count, target_word, corpus_count) AS result;


This statement list outputs the following string:


Found 151 occurrences of "methinks" across 38 Shakespeare works



###  ` UNNEST ` operator



unnest_operator:
{
UNNEST( array ) [ as_alias ]
| array_path [ as_alias ]
}
[ WITH OFFSET [ as_alias ] ]

array:
{ array_expression | array_path }

as_alias:
[AS] alias


The ` UNNEST ` operator takes an array and returns a table with one row for
each element in the array. The output of ` UNNEST ` is one  value table
column. For these ` ARRAY ` element types, ` SELECT * ` against the value
table column returns multiple columns:

* ` STRUCT `

Input values:

* ` array_expression ` : An expression that produces an array.
* ` array_path ` : The path to an ` ARRAY ` type.

* In an implicit ` UNNEST ` operation, the path must start with a  range variable  name.
* In an explicit ` UNNEST ` operation, the path can optionally start with a  range variable  name.

The ` UNNEST ` operation with any  correlated  ` array_path ` must be on the
right side of a ` CROSS JOIN ` , ` LEFT JOIN ` , or ` INNER JOIN ` operation.

* ` as_alias ` : If specified, defines the explicit name of the value table column containing the array element values. It can be used to refer to the column elsewhere in the query.

* ` WITH OFFSET ` : ` UNNEST ` destroys the order of elements in the input array. Use this optional clause to return an additional column with the array element indexes, or _offsets_ . Offset counting starts at zero for each row produced by the ` UNNEST ` operation. This column has an optional alias; If the optional alias is not used, the default column name is ` offset ` .

Example:


SELECT * FROM UNNEST ([10,20,30]) as numbers WITH OFFSET;

/*---------+--------*
| numbers | offset |
+---------+--------+
| 10      | 0      |
| 20      | 1      |
| 30      | 2      |
*---------+--------*/


You can also use ` UNNEST ` outside of the ` FROM ` clause with the [ ` IN `
operator ](/bigquery/docs/reference/standard-sql/operators#in_operators) .

For several ways to use ` UNNEST ` , including construction, flattening, and
filtering, see [ Work with arrays ](/bigquery/docs/arrays#working_with_arrays)
.

To learn more about the ways you can use ` UNNEST ` explicitly and implicitly,
see  Explicit and implicit ` UNNEST ` .

####  ` UNNEST ` and structs

For an input array of structs, ` UNNEST ` returns a row for each struct, with
a separate column for each field in the struct. The alias for each column is
the name of the corresponding struct field.

Example:



SELECT *
FROM UNNEST(
ARRAY<
STRUCT<
x INT64,
y STRING,
z STRUCT<a INT64, b INT64>>>[
(1, 'foo', (10, 11)),
(3, 'bar', (20, 21))]);

/*---+-----+----------*
| x | y   | z        |
+---+-----+----------+
| 1 | foo | {10, 11} |
| 3 | bar | {20, 21} |
*---+-----+----------*/


Because the ` UNNEST ` operator returns a  value table  , you can alias `
UNNEST ` to define a range variable that you can reference elsewhere in the
query. If you reference the range variable in the ` SELECT ` list, the query
returns a struct containing all of the fields of the original struct in the
input table.

Example:



SELECT *, struct_value
FROM UNNEST(
ARRAY<
STRUCT<
x INT64,
y STRING>>[
(1, 'foo'),
(3, 'bar')]) AS struct_value;

/*---+-----+--------------*
| x | y   | struct_value |
+---+-----+--------------+
| 3 | bar | {3, bar}     |
| 1 | foo | {1, foo}     |
*---+-----+--------------*/


####  Explicit and implicit ` UNNEST `

Array unnesting can be either explicit or implicit. To learn more, see the
following sections.

**Explicit unnesting**

The ` UNNEST ` keyword is required in explicit unnesting. For example:



WITH Coordinates AS (SELECT [1,2] AS position)
SELECT results FROM Coordinates, UNNEST(Coordinates.position) AS results;


In explicit unnesting, ` array_expression ` must return an array value but
doesn't need to resolve to an array.

**Implicit unnesting**

The ` UNNEST ` keyword is not used in implicit unnesting.

For example:



WITH Coordinates AS (SELECT [1,2] AS position)
SELECT results FROM Coordinates, Coordinates.position AS results;


**Tables and implicit unnesting**

When you use ` array_path ` with implicit ` UNNEST ` , ` array_path ` must be
prepended with the table. For example:



WITH Coordinates AS (SELECT [1,2] AS position)
SELECT results FROM Coordinates, Coordinates.position AS results;


####  ` UNNEST ` and ` NULL ` values

` UNNEST ` treats ` NULL ` values as follows:

* ` NULL ` and empty arrays produce zero rows.
* An array containing ` NULL ` values produces rows containing ` NULL ` values.


###  ` PIVOT ` operator



FROM from_item[, ...] pivot_operator

pivot_operator:
PIVOT(
aggregate_function_call [as_alias][, ...]
FOR input_column
IN ( pivot_column [as_alias][, ...] )
) [AS alias]

as_alias:
[AS] alias


The ` PIVOT ` operator rotates rows into columns, using aggregation. ` PIVOT `
is part of the ` FROM ` clause.

* ` PIVOT ` can be used to modify any table expression.
* Combining ` PIVOT ` with ` FOR SYSTEM_TIME AS OF ` is not allowed, although users may use ` PIVOT ` against a subquery input which itself uses ` FOR SYSTEM_TIME AS OF ` .
* A ` WITH OFFSET ` clause immediately preceding the ` PIVOT ` operator is not allowed.

Conceptual example:



-- Before PIVOT is used to rotate sales and quarter into Q1, Q2, Q3, Q4 columns:
/*---------+-------+---------+------*
| product | sales | quarter | year |
+---------+-------+---------+------|
| Kale    | 51    | Q1      | 2020 |
| Kale    | 23    | Q2      | 2020 |
| Kale    | 45    | Q3      | 2020 |
| Kale    | 3     | Q4      | 2020 |
| Kale    | 70    | Q1      | 2021 |
| Kale    | 85    | Q2      | 2021 |
| Apple   | 77    | Q1      | 2020 |
| Apple   | 0     | Q2      | 2020 |
| Apple   | 1     | Q1      | 2021 |
*---------+-------+---------+------*/

-- After PIVOT is used to rotate sales and quarter into Q1, Q2, Q3, Q4 columns:
/*---------+------+----+------+------+------*
| product | year | Q1 | Q2   | Q3   | Q4   |
+---------+------+----+------+------+------+
| Apple   | 2020 | 77 | 0    | NULL | NULL |
| Apple   | 2021 | 1  | NULL | NULL | NULL |
| Kale    | 2020 | 51 | 23   | 45   | 3    |
| Kale    | 2021 | 70 | 85   | NULL | NULL |
*---------+------+----+------+------+------*/


**Definitions**

Top-level definitions:

* ` from_item ` : The table or subquery on which to perform a pivot operation. The ` from_item ` must  follow these rules  .
* ` pivot_operator ` : The pivot operation to perform on a ` from_item ` .
* ` alias ` : An alias to use for an item in the query.

` pivot_operator ` definitions:

* ` aggregate_function_call ` : An aggregate function call that aggregates all input rows such that ` input_column ` matches a particular value in ` pivot_column ` . Each aggregation corresponding to a different ` pivot_column ` value produces a different column in the output.  Follow these rules  when creating an aggregate function call.
* ` input_column ` : Takes a column and retrieves the row values for the column,  following these rules  .
* ` pivot_column ` : A pivot column to create for each aggregate function call. If an alias is not provided, a default alias is created. A pivot column value type must match the value type in ` input_column ` so that the values can be compared. It is possible to have a value in ` pivot_column ` that doesn't match a value in ` input_column ` . Must be a constant and  follow these rules  .

**Rules**

Rules for a ` from_item ` passed to ` PIVOT ` :

* The ` from_item ` may consist of any table or subquery result.
* The ` from_item ` may not produce a value table.
* The ` from_item ` may not be a subquery using ` SELECT AS STRUCT ` .

Rules for ` aggregate_function_call ` :

* Must be an aggregate function. For example, ` SUM ` .
* You may reference columns in a table passed to ` PIVOT ` , as well as correlated columns, but may not access columns defined by the ` PIVOT ` clause itself.
* A table passed to ` PIVOT ` may be accessed through its alias if one is provided.
* You can only use an aggregate function that takes one argument.
* Except for ` COUNT ` , you can only use aggregate functions that ignore ` NULL ` inputs.
* If you are using ` COUNT ` , you can use ` * ` as an argument.

Rules for ` input_column ` :

* May access columns from the input table, as well as correlated columns, not columns defined by the ` PIVOT ` clause, itself.
* Evaluated against each row in the input table; aggregate and window function calls are prohibited.
* Non-determinism is okay.
* The type must be groupable.
* The input table may be accessed through its alias if one is provided.

Rules for ` pivot_column ` :

* A ` pivot_column ` must be a constant.
* Named constants, such as variables, are not supported.
* Query parameters are not supported.
* If a name is desired for a named constant or query parameter, specify it explicitly with an alias.
* Corner cases exist where a distinct ` pivot_column ` s can end up with the same default column names. For example, an input column might contain both a ` NULL ` value and the string literal ` "NULL" ` . When this happens, multiple pivot columns are created with the same name. To avoid this situation, use aliases for pivot column names.
* If a ` pivot_column ` doesn't specify an alias, a column name is constructed as follows:

From  |  To  |  Example
---|---|---
NULL  |  NULL  |  Input: NULL
Output: "NULL"

` INT64 `
` NUMERIC `
` BIGNUMERIC `
|  The number in string format with the following rules:

* Positive numbers are preceded with ` _ ` .
* Negative numbers are preceded with ` minus_ ` .
* A decimal point is replaced with ` _point_ ` .

|  Input: 1
Output: _1

* * *

Input: -1
Output: minus_1

* * *

Input: 1.0
Output: _1_point_0

BOOL  |  ` TRUE ` or ` FALSE ` .  |  Input: TRUE
Output: TRUE

* * *

Input: FALSE
Output: FALSE

STRING  |  The string value.  |  Input: "PlayerName"
Output: PlayerName

DATE  |  The date in ` _YYYY_MM_DD ` format.  |  Input: DATE '2013-11-25'
Output: _2013_11_25

ENUM  |  The name of the enumeration constant.  |  Input: COLOR.RED
Output: RED

STRUCT  |  A string formed by computing the ` pivot_column ` name for each
field and joining the results together with an underscore. The following rules
apply:

* If the field is named: ` <field_name>_<pivot_column_name_for_field_name> ` .
* If the field is unnamed: ` <pivot_column_name_for_field_name> ` .

` <pivot_column_name_for_field_name> ` is determined by applying the rules in
this table, recursively. If no rule is available for any ` STRUCT ` field, the
entire pivot column is unnamed.

Due to implicit type coercion from the ` IN ` list values to the type of `
<value-expression> ` , field names must be present in ` input_column ` to have
an effect on the names of the pivot columns.

|  Input: STRUCT("one", "two")
Output: one_two

* * *

Input: STRUCT("one" AS a, "two" AS b)
Output: one_a_two_b

All other data types  |  Not supported. You must provide an alias.  |

**Examples**

The following examples reference a table called ` Produce ` that looks like
this:



WITH Produce AS (
SELECT 'Kale' as product, 51 as sales, 'Q1' as quarter, 2020 as year UNION ALL
SELECT 'Kale', 23, 'Q2', 2020 UNION ALL
SELECT 'Kale', 45, 'Q3', 2020 UNION ALL
SELECT 'Kale', 3, 'Q4', 2020 UNION ALL
SELECT 'Kale', 70, 'Q1', 2021 UNION ALL
SELECT 'Kale', 85, 'Q2', 2021 UNION ALL
SELECT 'Apple', 77, 'Q1', 2020 UNION ALL
SELECT 'Apple', 0, 'Q2', 2020 UNION ALL
SELECT 'Apple', 1, 'Q1', 2021)
SELECT * FROM Produce

/*---------+-------+---------+------*
| product | sales | quarter | year |
+---------+-------+---------+------|
| Kale    | 51    | Q1      | 2020 |
| Kale    | 23    | Q2      | 2020 |
| Kale    | 45    | Q3      | 2020 |
| Kale    | 3     | Q4      | 2020 |
| Kale    | 70    | Q1      | 2021 |
| Kale    | 85    | Q2      | 2021 |
| Apple   | 77    | Q1      | 2020 |
| Apple   | 0     | Q2      | 2020 |
| Apple   | 1     | Q1      | 2021 |
*---------+-------+---------+------*/


With the ` PIVOT ` operator, the rows in the ` quarter ` column are rotated
into these new columns: ` Q1 ` , ` Q2 ` , ` Q3 ` , ` Q4 ` . The aggregate
function ` SUM ` is implicitly grouped by all unaggregated columns other than
the ` pivot_column ` : ` product ` and ` year ` .



SELECT * FROM
Produce
PIVOT(SUM(sales) FOR quarter IN ('Q1', 'Q2', 'Q3', 'Q4'))

/*---------+------+----+------+------+------*
| product | year | Q1 | Q2   | Q3   | Q4   |
+---------+------+----+------+------+------+
| Apple   | 2020 | 77 | 0    | NULL | NULL |
| Apple   | 2021 | 1  | NULL | NULL | NULL |
| Kale    | 2020 | 51 | 23   | 45   | 3    |
| Kale    | 2021 | 70 | 85   | NULL | NULL |
*---------+------+----+------+------+------*/


If you don't include ` year ` , then ` SUM ` is grouped only by ` product ` .



SELECT * FROM
(SELECT product, sales, quarter FROM Produce)
PIVOT(SUM(sales) FOR quarter IN ('Q1', 'Q2', 'Q3', 'Q4'))

/*---------+-----+-----+------+------*
| product | Q1  | Q2  | Q3   | Q4   |
+---------+-----+-----+------+------+
| Apple   | 78  | 0   | NULL | NULL |
| Kale    | 121 | 108 | 45   | 3    |
*---------+-----+-----+------+------*/


You can select a subset of values in the ` pivot_column ` :



SELECT * FROM
(SELECT product, sales, quarter FROM Produce)
PIVOT(SUM(sales) FOR quarter IN ('Q1', 'Q2', 'Q3'))

/*---------+-----+-----+------*
| product | Q1  | Q2  | Q3   |
+---------+-----+-----+------+
| Apple   | 78  | 0   | NULL |
| Kale    | 121 | 108 | 45   |
*---------+-----+-----+------*/



SELECT * FROM
(SELECT sales, quarter FROM Produce)
PIVOT(SUM(sales) FOR quarter IN ('Q1', 'Q2', 'Q3'))

/*-----+-----+----*
| Q1  | Q2  | Q3 |
+-----+-----+----+
| 199 | 108 | 45 |
*-----+-----+----*/


You can include multiple aggregation functions in the ` PIVOT ` . In this
case, you must specify an alias for each aggregation. These aliases are used
to construct the column names in the resulting table.



SELECT * FROM
(SELECT product, sales, quarter FROM Produce)
PIVOT(SUM(sales) total_sales, COUNT(*) num_records FOR quarter IN ('Q1', 'Q2'))

/*--------+----------------+----------------+----------------+----------------*
|product | total_sales_Q1 | num_records_Q1 | total_sales_Q2 | num_records_Q2 |
+--------+----------------+----------------+----------------+----------------+
| Kale   | 121            | 2              | 108            | 2              |
| Apple  | 78             | 2              | 0              | 1              |
*--------+----------------+----------------+----------------+----------------*/


###  ` UNPIVOT ` operator



FROM from_item[, ...] unpivot_operator

unpivot_operator:
UNPIVOT [ { INCLUDE NULLS | EXCLUDE NULLS } ] (
{ single_column_unpivot | multi_column_unpivot }
) [unpivot_alias]

single_column_unpivot:
values_column
FOR name_column
IN (columns_to_unpivot)

multi_column_unpivot:
values_column_set
FOR name_column
IN (column_sets_to_unpivot)

values_column_set:
(values_column[, ...])

columns_to_unpivot:
unpivot_column [row_value_alias][, ...]

column_sets_to_unpivot:
(unpivot_column [row_value_alias][, ...])

unpivot_alias and row_value_alias:
[AS] alias


The ` UNPIVOT ` operator rotates columns into rows. ` UNPIVOT ` is part of the
` FROM ` clause.

* ` UNPIVOT ` can be used to modify any table expression.
* Combining ` UNPIVOT ` with ` FOR SYSTEM_TIME AS OF ` is not allowed, although users may use ` UNPIVOT ` against a subquery input which itself uses ` FOR SYSTEM_TIME AS OF ` .
* A ` WITH OFFSET ` clause immediately preceding the ` UNPIVOT ` operator is not allowed.
* ` PIVOT ` aggregations cannot be reversed with ` UNPIVOT ` .

Conceptual example:



-- Before UNPIVOT is used to rotate Q1, Q2, Q3, Q4 into sales and quarter columns:
/*---------+----+----+----+----*
| product | Q1 | Q2 | Q3 | Q4 |
+---------+----+----+----+----+
| Kale    | 51 | 23 | 45 | 3  |
| Apple   | 77 | 0  | 25 | 2  |
*---------+----+----+----+----*/

-- After UNPIVOT is used to rotate Q1, Q2, Q3, Q4 into sales and quarter columns:
/*---------+-------+---------*
| product | sales | quarter |
+---------+-------+---------+
| Kale    | 51    | Q1      |
| Kale    | 23    | Q2      |
| Kale    | 45    | Q3      |
| Kale    | 3     | Q4      |
| Apple   | 77    | Q1      |
| Apple   | 0     | Q2      |
| Apple   | 25    | Q3      |
| Apple   | 2     | Q4      |
*---------+-------+---------*/


**Definitions**

Top-level definitions:

* ` from_item ` : The table or subquery on which to perform a pivot operation. The ` from_item ` must  follow these rules  .
* ` unpivot_operator ` : The pivot operation to perform on a ` from_item ` .

` unpivot_operator ` definitions:

* ` INCLUDE NULLS ` : Add rows with ` NULL ` values to the result.
* ` EXCLUDE NULLS ` : don't add rows with ` NULL ` values to the result. By default, ` UNPIVOT ` excludes rows with ` NULL ` values.
* ` single_column_unpivot ` : Rotates columns into one ` values_column ` and one ` name_column ` .
* ` multi_column_unpivot ` : Rotates columns into multiple ` values_column ` s and one ` name_column ` .
* ` unpivot_alias ` : An alias for the results of the ` UNPIVOT ` operation. This alias can be referenced elsewhere in the query.

` single_column_unpivot ` definitions:

* ` values_column ` : A column to contain the row values from ` columns_to_unpivot ` .  Follow these rules  when creating a values column.
* ` name_column ` : A column to contain the column names from ` columns_to_unpivot ` .  Follow these rules  when creating a name column.
* ` columns_to_unpivot ` : The columns from the ` from_item ` to populate ` values_column ` and ` name_column ` .  Follow these rules  when creating an unpivot column.
* ` row_value_alias ` : An optional alias for a column that is displayed for the column in ` name_column ` . If not specified, the string value of the column name is used.  Follow these rules  when creating a row value alias.

` multi_column_unpivot ` definitions:

* ` values_column_set ` : A set of columns to contain the row values from ` columns_to_unpivot ` .  Follow these rules  when creating a values column.
* ` name_column ` : A set of columns to contain the column names from ` columns_to_unpivot ` .  Follow these rules  when creating a name column.
* ` column_sets_to_unpivot ` : The columns from the ` from_item ` to unpivot.  Follow these rules  when creating an unpivot column.
* ` row_value_alias ` : An optional alias for a column set that is displayed for the column set in ` name_column ` . If not specified, a string value for the column set is used and each column in the string is separated with an underscore ( ` _ ` ). For example, ` (col1, col2) ` outputs ` col1_col2 ` .  Follow these rules  when creating a row value alias.

**Rules**

Rules for a ` from_item ` passed to ` UNPIVOT ` :

* The ` from_item ` may consist of any table or subquery result.
* The ` from_item ` may not produce a value table.
* Duplicate columns in a ` from_item ` cannot be referenced in the ` UNPIVOT ` clause.

Rules for ` unpivot_operator ` :

* Expressions are not permitted.
* Qualified names are not permitted. For example, ` mytable.mycolumn ` is not allowed.
* In the case where the ` UNPIVOT ` result has duplicate column names:
* ` SELECT * ` is allowed.
* ` SELECT values_column ` causes ambiguity.

Rules for ` values_column ` :

* It cannot be a name used for a ` name_column ` or an ` unpivot_column ` .
* It can be the same name as a column from the ` from_item ` .

Rules for ` name_column ` :

* It cannot be a name used for a ` values_column ` or an ` unpivot_column ` .
* It can be the same name as a column from the ` from_item ` .

Rules for ` unpivot_column ` :

* Must be a column name from the ` from_item ` .
* It cannot reference duplicate ` from_item ` column names.
* All columns in a column set must have equivalent data types.
* Data types cannot be coerced to a common supertype.
* If the data types are exact matches (for example, a struct with different field names), the data type of the first input is the data type of the output.
* You cannot have the same name in the same column set. For example, ` (emp1, emp1) ` results in an error.
* You can have a the same name in different column sets. For example, ` (emp1, emp2), (emp1, emp3) ` is valid.

Rules for ` row_value_alias ` :

* This can be a string or an ` INT64 ` literal.
* The data type for all ` row_value_alias ` clauses must be the same.
* If the value is an ` INT64 ` , the ` row_value_alias ` for each ` unpivot_column ` must be specified.

**Examples**

The following examples reference a table called ` Produce ` that looks like
this:



WITH Produce AS (
SELECT 'Kale' as product, 51 as Q1, 23 as Q2, 45 as Q3, 3 as Q4 UNION ALL
SELECT 'Apple', 77, 0, 25, 2)
SELECT * FROM Produce

/*---------+----+----+----+----*
| product | Q1 | Q2 | Q3 | Q4 |
+---------+----+----+----+----+
| Kale    | 51 | 23 | 45 | 3  |
| Apple   | 77 | 0  | 25 | 2  |
*---------+----+----+----+----*/


With the ` UNPIVOT ` operator, the columns ` Q1 ` , ` Q2 ` , ` Q3 ` , and ` Q4
` are rotated. The values of these columns now populate a new column called `
Sales ` and the names of these columns now populate a new column called `
Quarter ` . This is a single-column unpivot operation.



SELECT * FROM Produce
UNPIVOT(sales FOR quarter IN (Q1, Q2, Q3, Q4))

/*---------+-------+---------*
| product | sales | quarter |
+---------+-------+---------+
| Kale    | 51    | Q1      |
| Kale    | 23    | Q2      |
| Kale    | 45    | Q3      |
| Kale    | 3     | Q4      |
| Apple   | 77    | Q1      |
| Apple   | 0     | Q2      |
| Apple   | 25    | Q3      |
| Apple   | 2     | Q4      |
*---------+-------+---------*/


In this example, we ` UNPIVOT ` four quarters into two semesters. This is a
multi-column unpivot operation.



SELECT * FROM Produce
UNPIVOT(
(first_half_sales, second_half_sales)
FOR semesters
IN ((Q1, Q2) AS 'semester_1', (Q3, Q4) AS 'semester_2'))

/*---------+------------------+-------------------+------------*
| product | first_half_sales | second_half_sales | semesters  |
+---------+------------------+-------------------+------------+
| Kale    | 51               | 23                | semester_1 |
| Kale    | 45               | 3                 | semester_2 |
| Apple   | 77               | 0                 | semester_1 |
| Apple   | 25               | 2                 | semester_2 |
*---------+------------------+-------------------+------------*/


###  ` TABLESAMPLE ` operator



TABLESAMPLE SYSTEM ( percent PERCENT )


**Description**

You can use the ` TABLESAMPLE ` operator to select a random sample of a
dataset. This operator is useful when you're working with tables that have
large amounts of data and you don't need precise answers.

Sampling returns a variety of records while avoiding the costs associated with
scanning and processing an entire table. Each execution of the query might
return different results because each execution processes an independently
computed sample. GoogleSQL doesn't cache the results of queries that include a
` TABLESAMPLE ` clause.

Replace ` percent ` with the percentage of the dataset that you want to
include in the results. The value must be between ` 0 ` and ` 100 ` . The
value can be a literal value or a query parameter. It cannot be a variable.

For more information, see [ Table sampling ](/bigquery/docs/table-sampling) .

**Example**

The following query selects approximately 10% of a table's data:



SELECT * FROM dataset.my_table TABLESAMPLE SYSTEM (10 PERCENT)




###  ` ARRAY_SUBSCRIPT ` operator



array_expression[array_subscript_specifier]

array_subscript_specifier:
{ index | position_keyword(index) }

position_keyword:
{ OFFSET | SAFE_OFFSET | ORDINAL | SAFE_ORDINAL }


**Note:** The brackets ( ` [] ` ) around ` array_subscript_specifier ` are
part of the syntax; they do not represent an optional part.

**Description**

Gets a value from an array at a specific position.

Input values:

* ` array_expression ` : The input array.
* ` position_keyword(index) ` : Determines where the index for the array should start and how out-of-range indexes are handled. The index is an integer that represents a specific position in the array.
* ` OFFSET(index) ` : The index starts at zero. Produces an error if the index is out of range. To produce ` NULL ` instead of an error, use ` SAFE_OFFSET(index) ` . This position keyword produces the same result as ` index ` by itself.
* ` SAFE_OFFSET(index) ` : The index starts at zero. Returns ` NULL ` if the index is out of range.
* ` ORDINAL(index) ` : The index starts at one. Produces an error if the index is out of range. To produce ` NULL ` instead of an error, use ` SAFE_ORDINAL(index) ` .
* ` SAFE_ORDINAL(index) ` : The index starts at one. Returns ` NULL ` if the index is out of range.
* ` index ` : An integer that represents a specific position in the array. If used by itself without a position keyword, the index starts at zero and produces an error if the index is out of range. To produce ` NULL ` instead of an error, use the ` SAFE_OFFSET(index) ` or ` SAFE_ORDINAL(index) ` position keyword.

**Return type**

` T ` where ` array_expression ` is ` ARRAY<T> ` .

**Examples**

In following query, the array subscript operator is used to return values at
specific position in ` item_array ` . This query also shows what happens when
you reference an index ( ` 6 ` ) in an array that is out of range. If the `
SAFE ` prefix is included, ` NULL ` is returned, otherwise an error is
produced.



WITH Items AS (SELECT ["coffee", "tea", "milk"] AS item_array)
SELECT
item_array,
item_array[0] AS item_index,
item_array[OFFSET(0)] AS item_offset,
item_array[ORDINAL(1)] AS item_ordinal,
item_array[SAFE_OFFSET(6)] AS item_safe_offset
FROM Items

/*---------------------+------------+-------------+--------------+------------------*
| item_array          | item_index | item_offset | item_ordinal | item_safe_offset |
+---------------------+------------+-------------+--------------+------------------+
| [coffee, tea, milk] | coffee     | coffee      | coffee       | NULL             |
*----------------------------------+-------------+--------------+------------------*/


When you reference an index that is out of range in an array, and a positional
keyword that begins with ` SAFE ` is not included, an error is produced. For
example:



WITH Items AS (SELECT ["coffee", "tea", "milk"] AS item_array)
SELECT
item_array[6] AS item_offset
FROM Items

-- Error. Array index 6 is out of bounds.



WITH Items AS (SELECT ["coffee", "tea", "milk"] AS item_array)
SELECT
item_array[OFFSET(6)] AS item_offset
FROM Items

-- Error. Array index 6 is out of bounds.


###  ` STRUCT_SUBSCRIPT ` operator



struct_expression[struct_subscript_specifier]

struct_subscript_specifier:
{ index | position_keyword(index) }

position_keyword:
{ OFFSET | ORDINAL }


**Note:** The brackets ( ` [] ` ) around ` struct_subscript_specifier ` are
part of the syntax; they do not represent an optional part.

**Description**

Gets the value of a field at a selected position in a struct.

**Input types**

* ` struct_expression ` : The input struct.
* ` position_keyword(index) ` : Determines where the index for the struct should start and how out-of-range indexes are handled. The index is an integer literal or constant that represents a specific position in the struct.
* ` OFFSET(index) ` : The index starts at zero. Produces an error if the index is out of range. Produces the same result as ` index ` by itself.
* ` ORDINAL(index) ` : The index starts at one. Produces an error if the index is out of range.
* ` index ` : An integer literal or constant that represents a specific position in the struct. If used by itself without a position keyword, the index starts at zero and produces an error if the index is out of range.

**Note:** The struct subscript operator doesn't support ` SAFE ` positional
keywords at this time.

**Examples**

In following query, the struct subscript operator is used to return values at
specific locations in ` item_struct ` using position keywords. This query also
shows what happens when you reference an index ( ` 6 ` ) in an struct that is
out of range.



WITH Items AS (SELECT STRUCT<INT64, STRING, BOOL>(23, "tea", FALSE) AS item_struct)
SELECT
item_struct[0] AS field_index,
item_struct[OFFSET(0)] AS field_offset,
item_struct[ORDINAL(1)] AS field_ordinal
FROM Items

/*-------------+--------------+---------------*
| field_index | field_offset | field_ordinal |
+-------------+--------------+---------------+
| 23          | 23           | 23            |
*-------------+--------------+---------------*/


When you reference an index that is out of range in a struct, an error is
produced. For example:



WITH Items AS (SELECT STRUCT<INT64, STRING, BOOL>(23, "tea", FALSE) AS item_struct)
SELECT
item_struct[6] AS field_offset
FROM Items

-- Error. Field ordinal 6 is out of bounds in STRUCT



WITH Items AS (SELECT STRUCT<INT64, STRING, BOOL>(23, "tea", FALSE) AS item_struct)
SELECT
item_struct[OFFSET(6)] AS field_offset
FROM Items

-- Error. Field ordinal 6 is out of bounds in STRUCT



Send feedback