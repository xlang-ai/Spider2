{
    "table_name": "GITHUB_REPOS.SAMPLE_CONTENTS",
    "table_fullname": "GITHUB_REPOS.GITHUB_REPOS.SAMPLE_CONTENTS",
    "column_names": [
        "size",
        "binary",
        "sample_symlink_target",
        "copies",
        "sample_mode",
        "sample_path",
        "content",
        "sample_ref",
        "id",
        "sample_repo_name"
    ],
    "column_types": [
        "NUMBER",
        "BOOLEAN",
        "TEXT",
        "NUMBER",
        "NUMBER",
        "TEXT",
        "TEXT",
        "TEXT",
        "TEXT",
        "TEXT"
    ],
    "description": [
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null
    ],
    "sample_rows": [
        {
            "id": "2dd586a19b594a73e9c6f7485d1e5da9203a4467",
            "size": 21447,
            "content": "/*\n * rtc-ds1305.c -- driver for DS1305 and DS1306 SPI RTC chips\n *\n * Copyright (C) 2008 David Brownell\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation.\n *\n */\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/bcd.h>\n#include <linux/slab.h>\n#include <linux/rtc.h>\n#include <linux/workqueue.h>\n\n#include <linux/spi/spi.h>\n#include <linux/spi/ds1305.h>\n#include <linux/module.h>\n\n\n/*\n * Registers ... mask DS1305_WRITE into register address to write,\n * otherwise you're reading it.  All non-bitmask values are BCD.\n */\n#define DS1305_WRITE\t\t0x80\n\n\n/* RTC date/time ... the main special cases are that we:\n *  - Need fancy \"hours\" encoding in 12hour mode\n *  - Don't rely on the \"day-of-week\" field (or tm_wday)\n *  - Are a 21st-century clock (2000 <= year < 2100)\n */\n#define DS1305_RTC_LEN\t\t7\t\t/* bytes for RTC regs */\n\n#define DS1305_SEC\t\t0x00\t\t/* register addresses */\n#define DS1305_MIN\t\t0x01\n#define DS1305_HOUR\t\t0x02\n#\tdefine DS1305_HR_12\t\t0x40\t/* set == 12 hr mode */\n#\tdefine DS1305_HR_PM\t\t0x20\t/* set == PM (12hr mode) */\n#define DS1305_WDAY\t\t0x03\n#define DS1305_MDAY\t\t0x04\n#define DS1305_MON\t\t0x05\n#define DS1305_YEAR\t\t0x06\n\n\n/* The two alarms have only sec/min/hour/wday fields (ALM_LEN).\n * DS1305_ALM_DISABLE disables a match field (some combos are bad).\n *\n * NOTE that since we don't use WDAY, we limit ourselves to alarms\n * only one day into the future (vs potentially up to a week).\n *\n * NOTE ALSO that while we could generate once-a-second IRQs (UIE), we\n * don't currently support them.  We'd either need to do it only when\n * no alarm is pending (not the standard model), or to use the second\n * alarm (implying that this is a DS1305 not DS1306, *and* that either\n * it's wired up a second IRQ we know, or that INTCN is set)\n */\n#define DS1305_ALM_LEN\t\t4\t\t/* bytes for ALM regs */\n#define DS1305_ALM_DISABLE\t0x80\n\n#define DS1305_ALM0(r)\t\t(0x07 + (r))\t/* register addresses */\n#define DS1305_ALM1(r)\t\t(0x0b + (r))\n\n\n/* three control registers */\n#define DS1305_CONTROL_LEN\t3\t\t/* bytes of control regs */\n\n#define DS1305_CONTROL\t\t0x0f\t\t/* register addresses */\n#\tdefine DS1305_nEOSC\t\t0x80\t/* low enables oscillator */\n#\tdefine DS1305_WP\t\t0x40\t/* write protect */\n#\tdefine DS1305_INTCN\t\t0x04\t/* clear == only int0 used */\n#\tdefine DS1306_1HZ\t\t0x04\t/* enable 1Hz output */\n#\tdefine DS1305_AEI1\t\t0x02\t/* enable ALM1 IRQ */\n#\tdefine DS1305_AEI0\t\t0x01\t/* enable ALM0 IRQ */\n#define DS1305_STATUS\t\t0x10\n/* status has just AEIx bits, mirrored as IRQFx */\n#define DS1305_TRICKLE\t\t0x11\n/* trickle bits are defined in <linux/spi/ds1305.h> */\n\n/* a bunch of NVRAM */\n#define DS1305_NVRAM_LEN\t96\t\t/* bytes of NVRAM */\n\n#define DS1305_NVRAM\t\t0x20\t\t/* register addresses */\n\n\nstruct ds1305 {\n\tstruct spi_device\t*spi;\n\tstruct rtc_device\t*rtc;\n\n\tstruct work_struct\twork;\n\n\tunsigned long\t\tflags;\n#define FLAG_EXITING\t0\n\n\tbool\t\t\thr12;\n\tu8\t\t\tctrl[DS1305_CONTROL_LEN];\n};\n\n\n/*----------------------------------------------------------------------*/\n\n/*\n * Utilities ...  tolerate 12-hour AM/PM notation in case of non-Linux\n * software (like a bootloader) which may require it.\n */\n\nstatic unsigned bcd2hour(u8 bcd)\n{\n\tif (bcd & DS1305_HR_12) {\n\t\tunsigned\thour = 0;\n\n\t\tbcd &= ~DS1305_HR_12;\n\t\tif (bcd & DS1305_HR_PM) {\n\t\t\thour = 12;\n\t\t\tbcd &= ~DS1305_HR_PM;\n\t\t}\n\t\thour += bcd2bin(bcd);\n\t\treturn hour - 1;\n\t}\n\treturn bcd2bin(bcd);\n}\n\nstatic u8 hour2bcd(bool hr12, int hour)\n{\n\tif (hr12) {\n\t\thour++;\n\t\tif (hour <= 12)\n\t\t\treturn DS1305_HR_12 | bin2bcd(hour);\n\t\thour -= 12;\n\t\treturn DS1305_HR_12 | DS1305_HR_PM | bin2bcd(hour);\n\t}\n\treturn bin2bcd(hour);\n}\n\n/*----------------------------------------------------------------------*/\n\n/*\n * Interface to RTC framework\n */\n\nstatic int ds1305_alarm_irq_enable(struct device *dev, unsigned int enabled)\n{\n\tstruct ds1305\t*ds1305 = dev_get_drvdata(dev);\n\tu8\t\tbuf[2];\n\tlong\t\terr = -EINVAL;\n\n\tbuf[0] = DS1305_WRITE | DS1305_CONTROL;\n\tbuf[1] = ds1305->ctrl[0];\n\n\tif (enabled) {\n\t\tif (ds1305->ctrl[0] & DS1305_AEI0)\n\t\t\tgoto done;\n\t\tbuf[1] |= DS1305_AEI0;\n\t} else {\n\t\tif (!(buf[1] & DS1305_AEI0))\n\t\t\tgoto done;\n\t\tbuf[1] &= ~DS1305_AEI0;\n\t}\n\terr = spi_write_then_read(ds1305->spi, buf, sizeof(buf), NULL, 0);\n\tif (err >= 0)\n\t\tds1305->ctrl[0] = buf[1];\ndone:\n\treturn err;\n\n}\n\n\n/*\n * Get/set of date and time is pretty normal.\n */\n\nstatic int ds1305_get_time(struct device *dev, struct rtc_time *time)\n{\n\tstruct ds1305\t*ds1305 = dev_get_drvdata(dev);\n\tu8\t\taddr = DS1305_SEC;\n\tu8\t\tbuf[DS1305_RTC_LEN];\n\tint\t\tstatus;\n\n\t/* Use write-then-read to get all the date/time registers\n\t * since dma from stack is nonportable\n\t */\n\tstatus = spi_write_then_read(ds1305->spi, &addr, sizeof(addr),\n\t\t\tbuf, sizeof(buf));\n\tif (status < 0)\n\t\treturn status;\n\n\tdev_vdbg(dev, \"%s: %02x %02x %02x, %02x %02x %02x %02x\\n\",\n\t\t\"read\", buf[0], buf[1], buf[2], buf[3],\n\t\tbuf[4], buf[5], buf[6]);\n\n\t/* Decode the registers */\n\ttime->tm_sec = bcd2bin(buf[DS1305_SEC]);\n\ttime->tm_min = bcd2bin(buf[DS1305_MIN]);\n\ttime->tm_hour = bcd2hour(buf[DS1305_HOUR]);\n\ttime->tm_wday = buf[DS1305_WDAY] - 1;\n\ttime->tm_mday = bcd2bin(buf[DS1305_MDAY]);\n\ttime->tm_mon = bcd2bin(buf[DS1305_MON]) - 1;\n\ttime->tm_year = bcd2bin(buf[DS1305_YEAR]) + 100;\n\n\tdev_vdbg(dev, \"%s secs=%d, mins=%d, \"\n\t\t\"hours=%d, mday=%d, mon=%d, year=%d, wday=%d\\n\",\n\t\t\"read\", time->tm_sec, time->tm_min,\n\t\ttime->tm_hour, time->tm_mday,\n\t\ttime->tm_mon, time->tm_year, time->tm_wday);\n\n\t/* Time may not be set */\n\treturn rtc_valid_tm(time);\n}\n\nstatic int ds1305_set_time(struct device *dev, struct rtc_time *time)\n{\n\tstruct ds1305\t*ds1305 = dev_get_drvdata(dev);\n\tu8\t\tbuf[1 + DS1305_RTC_LEN];\n\tu8\t\t*bp = buf;\n\n\tdev_vdbg(dev, \"%s secs=%d, mins=%d, \"\n\t\t\"hours=%d, mday=%d, mon=%d, year=%d, wday=%d\\n\",\n\t\t\"write\", time->tm_sec, time->tm_min,\n\t\ttime->tm_hour, time->tm_mday,\n\t\ttime->tm_mon, time->tm_year, time->tm_wday);\n\n\t/* Write registers starting at the first time/date address. */\n\t*bp++ = DS1305_WRITE | DS1305_SEC;\n\n\t*bp++ = bin2bcd(time->tm_sec);\n\t*bp++ = bin2bcd(time->tm_min);\n\t*bp++ = hour2bcd(ds1305->hr12, time->tm_hour);\n\t*bp++ = (time->tm_wday < 7) ? (time->tm_wday + 1) : 1;\n\t*bp++ = bin2bcd(time->tm_mday);\n\t*bp++ = bin2bcd(time->tm_mon + 1);\n\t*bp++ = bin2bcd(time->tm_year - 100);\n\n\tdev_dbg(dev, \"%s: %02x %02x %02x, %02x %02x %02x %02x\\n\",\n\t\t\"write\", buf[1], buf[2], buf[3],\n\t\tbuf[4], buf[5], buf[6], buf[7]);\n\n\t/* use write-then-read since dma from stack is nonportable */\n\treturn spi_write_then_read(ds1305->spi, buf, sizeof(buf),\n\t\t\tNULL, 0);\n}\n\n/*\n * Get/set of alarm is a bit funky:\n *\n * - First there's the inherent raciness of getting the (partitioned)\n *   status of an alarm that could trigger while we're reading parts\n *   of that status.\n *\n * - Second there's its limited range (we could increase it a bit by\n *   relying on WDAY), which means it will easily roll over.\n *\n * - Third there's the choice of two alarms and alarm signals.\n *   Here we use ALM0 and expect that nINT0 (open drain) is used;\n *   that's the only real option for DS1306 runtime alarms, and is\n *   natural on DS1305.\n *\n * - Fourth, there's also ALM1, and a second interrupt signal:\n *     + On DS1305 ALM1 uses nINT1 (when INTCN=1) else nINT0;\n *     + On DS1306 ALM1 only uses INT1 (an active high pulse)\n *       and it won't work when VCC1 is active.\n *\n *   So to be most general, we should probably set both alarms to the\n *   same value, letting ALM1 be the wakeup event source on DS1306\n *   and handling several wiring options on DS1305.\n *\n * - Fifth, we support the polled mode (as well as possible; why not?)\n *   even when no interrupt line is wired to an IRQ.\n */\n\n/*\n * Context: caller holds rtc->ops_lock (to protect ds1305->ctrl)\n */\nstatic int ds1305_get_alarm(struct device *dev, struct rtc_wkalrm *alm)\n{\n\tstruct ds1305\t*ds1305 = dev_get_drvdata(dev);\n\tstruct spi_device *spi = ds1305->spi;\n\tu8\t\taddr;\n\tint\t\tstatus;\n\tu8\t\tbuf[DS1305_ALM_LEN];\n\n\t/* Refresh control register cache BEFORE reading ALM0 registers,\n\t * since reading alarm registers acks any pending IRQ.  That\n\t * makes returning \"pending\" status a bit of a lie, but that bit\n\t * of EFI status is at best fragile anyway (given IRQ handlers).\n\t */\n\taddr = DS1305_CONTROL;\n\tstatus = spi_write_then_read(spi, &addr, sizeof(addr),\n\t\t\tds1305->ctrl, sizeof(ds1305->ctrl));\n\tif (status < 0)\n\t\treturn status;\n\n\talm->enabled = !!(ds1305->ctrl[0] & DS1305_AEI0);\n\talm->pending = !!(ds1305->ctrl[1] & DS1305_AEI0);\n\n\t/* get and check ALM0 registers */\n\taddr = DS1305_ALM0(DS1305_SEC);\n\tstatus = spi_write_then_read(spi, &addr, sizeof(addr),\n\t\t\tbuf, sizeof(buf));\n\tif (status < 0)\n\t\treturn status;\n\n\tdev_vdbg(dev, \"%s: %02x %02x %02x %02x\\n\",\n\t\t\"alm0 read\", buf[DS1305_SEC], buf[DS1305_MIN],\n\t\tbuf[DS1305_HOUR], buf[DS1305_WDAY]);\n\n\tif ((DS1305_ALM_DISABLE & buf[DS1305_SEC])\n\t\t\t|| (DS1305_ALM_DISABLE & buf[DS1305_MIN])\n\t\t\t|| (DS1305_ALM_DISABLE & buf[DS1305_HOUR]))\n\t\treturn -EIO;\n\n\t/* Stuff these values into alm->time and let RTC framework code\n\t * fill in the rest ... and also handle rollover to tomorrow when\n\t * that's needed.\n\t */\n\talm->time.tm_sec = bcd2bin(buf[DS1305_SEC]);\n\talm->time.tm_min = bcd2bin(buf[DS1305_MIN]);\n\talm->time.tm_hour = bcd2hour(buf[DS1305_HOUR]);\n\talm->time.tm_mday = -1;\n\talm->time.tm_mon = -1;\n\talm->time.tm_year = -1;\n\t/* next three fields are unused by Linux */\n\talm->time.tm_wday = -1;\n\talm->time.tm_mday = -1;\n\talm->time.tm_isdst = -1;\n\n\treturn 0;\n}\n\n/*\n * Context: caller holds rtc->ops_lock (to protect ds1305->ctrl)\n */\nstatic int ds1305_set_alarm(struct device *dev, struct rtc_wkalrm *alm)\n{\n\tstruct ds1305\t*ds1305 = dev_get_drvdata(dev);\n\tstruct spi_device *spi = ds1305->spi;\n\tunsigned long\tnow, later;\n\tstruct rtc_time\ttm;\n\tint\t\tstatus;\n\tu8\t\tbuf[1 + DS1305_ALM_LEN];\n\n\t/* convert desired alarm to time_t */\n\tstatus = rtc_tm_to_time(&alm->time, &later);\n\tif (status < 0)\n\t\treturn status;\n\n\t/* Read current time as time_t */\n\tstatus = ds1305_get_time(dev, &tm);\n\tif (status < 0)\n\t\treturn status;\n\tstatus = rtc_tm_to_time(&tm, &now);\n\tif (status < 0)\n\t\treturn status;\n\n\t/* make sure alarm fires within the next 24 hours */\n\tif (later <= now)\n\t\treturn -EINVAL;\n\tif ((later - now) > 24 * 60 * 60)\n\t\treturn -EDOM;\n\n\t/* disable alarm if needed */\n\tif (ds1305->ctrl[0] & DS1305_AEI0) {\n\t\tds1305->ctrl[0] &= ~DS1305_AEI0;\n\n\t\tbuf[0] = DS1305_WRITE | DS1305_CONTROL;\n\t\tbuf[1] = ds1305->ctrl[0];\n\t\tstatus = spi_write_then_read(ds1305->spi, buf, 2, NULL, 0);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\n\t/* write alarm */\n\tbuf[0] = DS1305_WRITE | DS1305_ALM0(DS1305_SEC);\n\tbuf[1 + DS1305_SEC] = bin2bcd(alm->time.tm_sec);\n\tbuf[1 + DS1305_MIN] = bin2bcd(alm->time.tm_min);\n\tbuf[1 + DS1305_HOUR] = hour2bcd(ds1305->hr12, alm->time.tm_hour);\n\tbuf[1 + DS1305_WDAY] = DS1305_ALM_DISABLE;\n\n\tdev_dbg(dev, \"%s: %02x %02x %02x %02x\\n\",\n\t\t\"alm0 write\", buf[1 + DS1305_SEC], buf[1 + DS1305_MIN],\n\t\tbuf[1 + DS1305_HOUR], buf[1 + DS1305_WDAY]);\n\n\tstatus = spi_write_then_read(spi, buf, sizeof(buf), NULL, 0);\n\tif (status < 0)\n\t\treturn status;\n\n\t/* enable alarm if requested */\n\tif (alm->enabled) {\n\t\tds1305->ctrl[0] |= DS1305_AEI0;\n\n\t\tbuf[0] = DS1305_WRITE | DS1305_CONTROL;\n\t\tbuf[1] = ds1305->ctrl[0];\n\t\tstatus = spi_write_then_read(ds1305->spi, buf, 2, NULL, 0);\n\t}\n\n\treturn status;\n}\n\n#ifdef CONFIG_PROC_FS\n\nstatic int ds1305_proc(struct device *dev, struct seq_file *seq)\n{\n\tstruct ds1305\t*ds1305 = dev_get_drvdata(dev);\n\tchar\t\t*diodes = \"no\";\n\tchar\t\t*resistors = \"\";\n\n\t/* ctrl[2] is treated as read-only; no locking needed */\n\tif ((ds1305->ctrl[2] & 0xf0) == DS1305_TRICKLE_MAGIC) {\n\t\tswitch (ds1305->ctrl[2] & 0x0c) {\n\t\tcase DS1305_TRICKLE_DS2:\n\t\t\tdiodes = \"2 diodes, \";\n\t\t\tbreak;\n\t\tcase DS1305_TRICKLE_DS1:\n\t\t\tdiodes = \"1 diode, \";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto done;\n\t\t}\n\t\tswitch (ds1305->ctrl[2] & 0x03) {\n\t\tcase DS1305_TRICKLE_2K:\n\t\t\tresistors = \"2k Ohm\";\n\t\t\tbreak;\n\t\tcase DS1305_TRICKLE_4K:\n\t\t\tresistors = \"4k Ohm\";\n\t\t\tbreak;\n\t\tcase DS1305_TRICKLE_8K:\n\t\t\tresistors = \"8k Ohm\";\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdiodes = \"no\";\n\t\t\tbreak;\n\t\t}\n\t}\n\ndone:\n\treturn seq_printf(seq,\n\t\t\t\"trickle_charge\\t: %s%s\\n\",\n\t\t\tdiodes, resistors);\n}\n\n#else\n#define ds1305_proc\tNULL\n#endif\n\nstatic const struct rtc_class_ops ds1305_ops = {\n\t.read_time\t= ds1305_get_time,\n\t.set_time\t= ds1305_set_time,\n\t.read_alarm\t= ds1305_get_alarm,\n\t.set_alarm\t= ds1305_set_alarm,\n\t.proc\t\t= ds1305_proc,\n\t.alarm_irq_enable = ds1305_alarm_irq_enable,\n};\n\nstatic void ds1305_work(struct work_struct *work)\n{\n\tstruct ds1305\t*ds1305 = container_of(work, struct ds1305, work);\n\tstruct mutex\t*lock = &ds1305->rtc->ops_lock;\n\tstruct spi_device *spi = ds1305->spi;\n\tu8\t\tbuf[3];\n\tint\t\tstatus;\n\n\t/* lock to protect ds1305->ctrl */\n\tmutex_lock(lock);\n\n\t/* Disable the IRQ, and clear its status ... for now, we \"know\"\n\t * that if more than one alarm is active, they're in sync.\n\t * Note that reading ALM data registers also clears IRQ status.\n\t */\n\tds1305->ctrl[0] &= ~(DS1305_AEI1 | DS1305_AEI0);\n\tds1305->ctrl[1] = 0;\n\n\tbuf[0] = DS1305_WRITE | DS1305_CONTROL;\n\tbuf[1] = ds1305->ctrl[0];\n\tbuf[2] = 0;\n\n\tstatus = spi_write_then_read(spi, buf, sizeof(buf),\n\t\t\tNULL, 0);\n\tif (status < 0)\n\t\tdev_dbg(&spi->dev, \"clear irq --> %d\\n\", status);\n\n\tmutex_unlock(lock);\n\n\tif (!test_bit(FLAG_EXITING, &ds1305->flags))\n\t\tenable_irq(spi->irq);\n\n\trtc_update_irq(ds1305->rtc, 1, RTC_AF | RTC_IRQF);\n}\n\n/*\n * This \"real\" IRQ handler hands off to a workqueue mostly to allow\n * mutex locking for ds1305->ctrl ... unlike I2C, we could issue async\n * I/O requests in IRQ context (to clear the IRQ status).\n */\nstatic irqreturn_t ds1305_irq(int irq, void *p)\n{\n\tstruct ds1305\t\t*ds1305 = p;\n\n\tdisable_irq(irq);\n\tschedule_work(&ds1305->work);\n\treturn IRQ_HANDLED;\n}\n\n/*----------------------------------------------------------------------*/\n\n/*\n * Interface for NVRAM\n */\n\nstatic void msg_init(struct spi_message *m, struct spi_transfer *x,\n\t\tu8 *addr, size_t count, char *tx, char *rx)\n{\n\tspi_message_init(m);\n\tmemset(x, 0, 2 * sizeof(*x));\n\n\tx->tx_buf = addr;\n\tx->len = 1;\n\tspi_message_add_tail(x, m);\n\n\tx++;\n\n\tx->tx_buf = tx;\n\tx->rx_buf = rx;\n\tx->len = count;\n\tspi_message_add_tail(x, m);\n}\n\nstatic ssize_t\nds1305_nvram_read(struct file *filp, struct kobject *kobj,\n\t\tstruct bin_attribute *attr,\n\t\tchar *buf, loff_t off, size_t count)\n{\n\tstruct spi_device\t*spi;\n\tu8\t\t\taddr;\n\tstruct spi_message\tm;\n\tstruct spi_transfer\tx[2];\n\tint\t\t\tstatus;\n\n\tspi = container_of(kobj, struct spi_device, dev.kobj);\n\n\tif (unlikely(off >= DS1305_NVRAM_LEN))\n\t\treturn 0;\n\tif (count >= DS1305_NVRAM_LEN)\n\t\tcount = DS1305_NVRAM_LEN;\n\tif ((off + count) > DS1305_NVRAM_LEN)\n\t\tcount = DS1305_NVRAM_LEN - off;\n\tif (unlikely(!count))\n\t\treturn count;\n\n\taddr = DS1305_NVRAM + off;\n\tmsg_init(&m, x, &addr, count, NULL, buf);\n\n\tstatus = spi_sync(spi, &m);\n\tif (status < 0)\n\t\tdev_err(&spi->dev, \"nvram %s error %d\\n\", \"read\", status);\n\treturn (status < 0) ? status : count;\n}\n\nstatic ssize_t\nds1305_nvram_write(struct file *filp, struct kobject *kobj,\n\t\tstruct bin_attribute *attr,\n\t\tchar *buf, loff_t off, size_t count)\n{\n\tstruct spi_device\t*spi;\n\tu8\t\t\taddr;\n\tstruct spi_message\tm;\n\tstruct spi_transfer\tx[2];\n\tint\t\t\tstatus;\n\n\tspi = container_of(kobj, struct spi_device, dev.kobj);\n\n\tif (unlikely(off >= DS1305_NVRAM_LEN))\n\t\treturn -EFBIG;\n\tif (count >= DS1305_NVRAM_LEN)\n\t\tcount = DS1305_NVRAM_LEN;\n\tif ((off + count) > DS1305_NVRAM_LEN)\n\t\tcount = DS1305_NVRAM_LEN - off;\n\tif (unlikely(!count))\n\t\treturn count;\n\n\taddr = (DS1305_WRITE | DS1305_NVRAM) + off;\n\tmsg_init(&m, x, &addr, count, buf, NULL);\n\n\tstatus = spi_sync(spi, &m);\n\tif (status < 0)\n\t\tdev_err(&spi->dev, \"nvram %s error %d\\n\", \"write\", status);\n\treturn (status < 0) ? status : count;\n}\n\nstatic struct bin_attribute nvram = {\n\t.attr.name\t= \"nvram\",\n\t.attr.mode\t= S_IRUGO | S_IWUSR,\n\t.read\t\t= ds1305_nvram_read,\n\t.write\t\t= ds1305_nvram_write,\n\t.size\t\t= DS1305_NVRAM_LEN,\n};\n\n/*----------------------------------------------------------------------*/\n\n/*\n * Interface to SPI stack\n */\n\nstatic int ds1305_probe(struct spi_device *spi)\n{\n\tstruct ds1305\t\t\t*ds1305;\n\tint\t\t\t\tstatus;\n\tu8\t\t\t\taddr, value;\n\tstruct ds1305_platform_data\t*pdata = dev_get_platdata(&spi->dev);\n\tbool\t\t\t\twrite_ctrl = false;\n\n\t/* Sanity check board setup data.  This may be hooked up\n\t * in 3wire mode, but we don't care.  Note that unless\n\t * there's an inverter in place, this needs SPI_CS_HIGH!\n\t */\n\tif ((spi->bits_per_word && spi->bits_per_word != 8)\n\t\t\t|| (spi->max_speed_hz > 2000000)\n\t\t\t|| !(spi->mode & SPI_CPHA))\n\t\treturn -EINVAL;\n\n\t/* set up driver data */\n\tds1305 = devm_kzalloc(&spi->dev, sizeof(*ds1305), GFP_KERNEL);\n\tif (!ds1305)\n\t\treturn -ENOMEM;\n\tds1305->spi = spi;\n\tspi_set_drvdata(spi, ds1305);\n\n\t/* read and cache control registers */\n\taddr = DS1305_CONTROL;\n\tstatus = spi_write_then_read(spi, &addr, sizeof(addr),\n\t\t\tds1305->ctrl, sizeof(ds1305->ctrl));\n\tif (status < 0) {\n\t\tdev_dbg(&spi->dev, \"can't %s, %d\\n\",\n\t\t\t\t\"read\", status);\n\t\treturn status;\n\t}\n\n\tdev_dbg(&spi->dev, \"ctrl %s: %3ph\\n\", \"read\", ds1305->ctrl);\n\n\t/* Sanity check register values ... partially compensating for the\n\t * fact that SPI has no device handshake.  A pullup on MISO would\n\t * make these tests fail; but not all systems will have one.  If\n\t * some register is neither 0x00 nor 0xff, a chip is likely there.\n\t */\n\tif ((ds1305->ctrl[0] & 0x38) != 0 || (ds1305->ctrl[1] & 0xfc) != 0) {\n\t\tdev_dbg(&spi->dev, \"RTC chip is not present\\n\");\n\t\treturn -ENODEV;\n\t}\n\tif (ds1305->ctrl[2] == 0)\n\t\tdev_dbg(&spi->dev, \"chip may not be present\\n\");\n\n\t/* enable writes if needed ... if we were paranoid it would\n\t * make sense to enable them only when absolutely necessary.\n\t */\n\tif (ds1305->ctrl[0] & DS1305_WP) {\n\t\tu8\t\tbuf[2];\n\n\t\tds1305->ctrl[0] &= ~DS1305_WP;\n\n\t\tbuf[0] = DS1305_WRITE | DS1305_CONTROL;\n\t\tbuf[1] = ds1305->ctrl[0];\n\t\tstatus = spi_write_then_read(spi, buf, sizeof(buf), NULL, 0);\n\n\t\tdev_dbg(&spi->dev, \"clear WP --> %d\\n\", status);\n\t\tif (status < 0)\n\t\t\treturn status;\n\t}\n\n\t/* on DS1305, maybe start oscillator; like most low power\n\t * oscillators, it may take a second to stabilize\n\t */\n\tif (ds1305->ctrl[0] & DS1305_nEOSC) {\n\t\tds1305->ctrl[0] &= ~DS1305_nEOSC;\n\t\twrite_ctrl = true;\n\t\tdev_warn(&spi->dev, \"SET TIME!\\n\");\n\t}\n\n\t/* ack any pending IRQs */\n\tif (ds1305->ctrl[1]) {\n\t\tds1305->ctrl[1] = 0;\n\t\twrite_ctrl = true;\n\t}\n\n\t/* this may need one-time (re)init */\n\tif (pdata) {\n\t\t/* maybe enable trickle charge */\n\t\tif (((ds1305->ctrl[2] & 0xf0) != DS1305_TRICKLE_MAGIC)) {\n\t\t\tds1305->ctrl[2] = DS1305_TRICKLE_MAGIC\n\t\t\t\t\t\t| pdata->trickle;\n\t\t\twrite_ctrl = true;\n\t\t}\n\n\t\t/* on DS1306, configure 1 Hz signal */\n\t\tif (pdata->is_ds1306) {\n\t\t\tif (pdata->en_1hz) {\n\t\t\t\tif (!(ds1305->ctrl[0] & DS1306_1HZ)) {\n\t\t\t\t\tds1305->ctrl[0] |= DS1306_1HZ;\n\t\t\t\t\twrite_ctrl = true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (ds1305->ctrl[0] & DS1306_1HZ) {\n\t\t\t\t\tds1305->ctrl[0] &= ~DS1306_1HZ;\n\t\t\t\t\twrite_ctrl = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (write_ctrl) {\n\t\tu8\t\tbuf[4];\n\n\t\tbuf[0] = DS1305_WRITE | DS1305_CONTROL;\n\t\tbuf[1] = ds1305->ctrl[0];\n\t\tbuf[2] = ds1305->ctrl[1];\n\t\tbuf[3] = ds1305->ctrl[2];\n\t\tstatus = spi_write_then_read(spi, buf, sizeof(buf), NULL, 0);\n\t\tif (status < 0) {\n\t\t\tdev_dbg(&spi->dev, \"can't %s, %d\\n\",\n\t\t\t\t\t\"write\", status);\n\t\t\treturn status;\n\t\t}\n\n\t\tdev_dbg(&spi->dev, \"ctrl %s: %3ph\\n\", \"write\", ds1305->ctrl);\n\t}\n\n\t/* see if non-Linux software set up AM/PM mode */\n\taddr = DS1305_HOUR;\n\tstatus = spi_write_then_read(spi, &addr, sizeof(addr),\n\t\t\t\t&value, sizeof(value));\n\tif (status < 0) {\n\t\tdev_dbg(&spi->dev, \"read HOUR --> %d\\n\", status);\n\t\treturn status;\n\t}\n\n\tds1305->hr12 = (DS1305_HR_12 & value) != 0;\n\tif (ds1305->hr12)\n\t\tdev_dbg(&spi->dev, \"AM/PM\\n\");\n\n\t/* register RTC ... from here on, ds1305->ctrl needs locking */\n\tds1305->rtc = devm_rtc_device_register(&spi->dev, \"ds1305\",\n\t\t\t&ds1305_ops, THIS_MODULE);\n\tif (IS_ERR(ds1305->rtc)) {\n\t\tstatus = PTR_ERR(ds1305->rtc);\n\t\tdev_dbg(&spi->dev, \"register rtc --> %d\\n\", status);\n\t\treturn status;\n\t}\n\n\t/* Maybe set up alarm IRQ; be ready to handle it triggering right\n\t * away.  NOTE that we don't share this.  The signal is active low,\n\t * and we can't ack it before a SPI message delay.  We temporarily\n\t * disable the IRQ until it's acked, which lets us work with more\n\t * IRQ trigger modes (not all IRQ controllers can do falling edge).\n\t */\n\tif (spi->irq) {\n\t\tINIT_WORK(&ds1305->work, ds1305_work);\n\t\tstatus = devm_request_irq(&spi->dev, spi->irq, ds1305_irq,\n\t\t\t\t0, dev_name(&ds1305->rtc->dev), ds1305);\n\t\tif (status < 0) {\n\t\t\tdev_dbg(&spi->dev, \"request_irq %d --> %d\\n\",\n\t\t\t\t\tspi->irq, status);\n\t\t\treturn status;\n\t\t}\n\n\t\tdevice_set_wakeup_capable(&spi->dev, 1);\n\t}\n\n\t/* export NVRAM */\n\tstatus = sysfs_create_bin_file(&spi->dev.kobj, &nvram);\n\tif (status < 0) {\n\t\tdev_dbg(&spi->dev, \"register nvram --> %d\\n\", status);\n\t\treturn status;\n\t}\n\n\treturn 0;\n}\n\nstatic int ds1305_remove(struct spi_device *spi)\n{\n\tstruct ds1305 *ds1305 = spi_get_drvdata(spi);\n\n\tsysfs_remove_bin_file(&spi->dev.kobj, &nvram);\n\n\t/* carefully shut down irq and workqueue, if present */\n\tif (spi->irq) {\n\t\tset_bit(FLAG_EXITING, &ds1305->flags);\n\t\tdevm_free_irq(&spi->dev, spi->irq, ds1305);\n\t\tcancel_work_sync(&ds1305->work);\n\t}\n\n\treturn 0;\n}\n\nstatic struct spi_driver ds1305_driver = {\n\t.driver.name\t= \"rtc-ds1305\",\n\t.driver.owner\t= THIS_MODULE,\n\t.probe\t\t= ds1305_probe,\n\t.remove\t\t= ds1305_remove,\n\t/* REVISIT add suspend/resume */\n};\n\nmodule_spi_driver(ds1305_driver);\n\nMODULE_DESCRIPTION(\"RTC driver for DS1305 and DS1306 chips\");\nMODULE_LICENSE(\"GPL\");\nMODULE_ALIAS(\"spi:rtc-ds1305\");\n",
            "binary": false,
            "copies": 256,
            "sample_repo_name": "wandboard-org/linux",
            "sample_ref": "refs/heads/master",
            "sample_path": "drivers/rtc/rtc-ds1305.c",
            "sample_mode": 33188,
            "sample_symlink_target": null
        },
        {
            "id": "816b2d7412b432d86a4a36147255ec664f760193",
            "size": 3974,
            "content": "/*\n *  linux/drivers/devfreq/governor_simpleondemand.c\n *\n *  Copyright (C) 2011 Samsung Electronics\n *\tMyungJoo Ham <myungjoo.ham@samsung.com>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2 as\n * published by the Free Software Foundation.\n */\n\n#include <linux/errno.h>\n#include <linux/module.h>\n#include <linux/devfreq.h>\n#include <linux/math64.h>\n#include \"governor.h\"\n\n/* Default constants for DevFreq-Simple-Ondemand (DFSO) */\n#define DFSO_UPTHRESHOLD\t(90)\n#define DFSO_DOWNDIFFERENCTIAL\t(10)\nstatic int devfreq_simple_ondemand_func(struct devfreq *df,\n\t\t\t\t\tunsigned long *freq,\n\t\t\t\t\tu32 *flag)\n{\n\tstruct devfreq_dev_status stat;\n\tint err;\n\tunsigned long long a, b;\n\tunsigned int dfso_upthreshold = DFSO_UPTHRESHOLD;\n\tunsigned int dfso_downdifferential = DFSO_DOWNDIFFERENCTIAL;\n\tstruct devfreq_simple_ondemand_data *data = df->data;\n\tunsigned long max = (df->max_freq) ? df->max_freq : UINT_MAX;\n\tunsigned long min = (df->min_freq) ? df->min_freq : 0;\n\n\tstat.private_data = NULL;\n\n\terr = df->profile->get_dev_status(df->dev.parent, &stat);\n\tif (err)\n\t\treturn err;\n\n\tif (data) {\n\t\tif (data->upthreshold)\n\t\t\tdfso_upthreshold = data->upthreshold;\n\t\tif (data->downdifferential)\n\t\t\tdfso_downdifferential = data->downdifferential;\n\t}\n\tif (dfso_upthreshold > 100 ||\n\t    dfso_upthreshold < dfso_downdifferential)\n\t\treturn -EINVAL;\n\n\t/* Prevent overflow */\n\tif (stat.busy_time >= (1 << 24) || stat.total_time >= (1 << 24)) {\n\t\tstat.busy_time >>= 7;\n\t\tstat.total_time >>= 7;\n\t}\n\n\tif (data && data->simple_scaling) {\n\t\tif (stat.busy_time * 100 >\n\t\t    stat.total_time * dfso_upthreshold)\n\t\t\t*freq = max;\n\t\telse if (stat.busy_time * 100 <\n\t\t\t stat.total_time *\n\t\t\t (dfso_upthreshold - dfso_downdifferential))\n\t\t\t*freq = min;\n\t\telse\n\t\t\t*freq = df->previous_freq;\n\t\treturn 0;\n\t}\n\n\t/* Assume MAX if it is going to be divided by zero */\n\tif (stat.total_time == 0) {\n\t\t*freq = max;\n\t\treturn 0;\n\t}\n\n\t/* Set MAX if it's busy enough */\n\tif (stat.busy_time * 100 >\n\t    stat.total_time * dfso_upthreshold) {\n\t\t*freq = max;\n\t\treturn 0;\n\t}\n\n\t/* Set MAX if we do not know the initial frequency */\n\tif (stat.current_frequency == 0) {\n\t\t*freq = max;\n\t\treturn 0;\n\t}\n\n\t/* Keep the current frequency */\n\tif (stat.busy_time * 100 >\n\t    stat.total_time * (dfso_upthreshold - dfso_downdifferential)) {\n\t\t*freq = stat.current_frequency;\n\t\treturn 0;\n\t}\n\n\t/* Set the desired frequency based on the load */\n\ta = stat.busy_time;\n\ta *= stat.current_frequency;\n\tb = div_u64(a, stat.total_time);\n\tb *= 100;\n\tb = div_u64(b, (dfso_upthreshold - dfso_downdifferential / 2));\n\t*freq = (unsigned long) b;\n\n\tif (df->min_freq && *freq < df->min_freq)\n\t\t*freq = df->min_freq;\n\tif (df->max_freq && *freq > df->max_freq)\n\t\t*freq = df->max_freq;\n\n\treturn 0;\n}\n\nstatic int devfreq_simple_ondemand_handler(struct devfreq *devfreq,\n\t\t\t\tunsigned int event, void *data)\n{\n\tswitch (event) {\n\tcase DEVFREQ_GOV_START:\n\t\tdevfreq_monitor_start(devfreq);\n\t\tbreak;\n\n\tcase DEVFREQ_GOV_STOP:\n\t\tdevfreq_monitor_stop(devfreq);\n\t\tbreak;\n\n\tcase DEVFREQ_GOV_INTERVAL:\n\t\tdevfreq_interval_update(devfreq, (unsigned int *)data);\n\t\tbreak;\n\n\tcase DEVFREQ_GOV_SUSPEND:\n\t\tdevfreq_monitor_suspend(devfreq);\n\t\tbreak;\n\n\tcase DEVFREQ_GOV_RESUME:\n\t\tdevfreq_monitor_resume(devfreq);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic struct devfreq_governor devfreq_simple_ondemand = {\n\t.name = \"simple_ondemand\",\n\t.get_target_freq = devfreq_simple_ondemand_func,\n\t.event_handler = devfreq_simple_ondemand_handler,\n};\n\nstatic int __init devfreq_simple_ondemand_init(void)\n{\n\treturn devfreq_add_governor(&devfreq_simple_ondemand);\n}\nsubsys_initcall(devfreq_simple_ondemand_init);\n\nstatic void __exit devfreq_simple_ondemand_exit(void)\n{\n\tint ret;\n\n\tret = devfreq_remove_governor(&devfreq_simple_ondemand);\n\tif (ret)\n\t\tpr_err(\"%s: failed remove governor %d\\n\", __func__, ret);\n\n\treturn;\n}\nmodule_exit(devfreq_simple_ondemand_exit);\nMODULE_LICENSE(\"GPL\");\n",
            "binary": false,
            "copies": 1,
            "sample_repo_name": "garwedgess/android_kernel_lge_g4",
            "sample_ref": "refs/heads/M",
            "sample_path": "drivers/devfreq/governor_simpleondemand.c",
            "sample_mode": 33188,
            "sample_symlink_target": null
        },
        {
            "id": "f50a76cff9f42438026c7cf8bba687bcd2d491ea",
            "size": 7866,
            "content": "/*\n  Copyright (c) 2015, Oracle and/or its affiliates. All rights reserved.\n\n  This program is free software; you can redistribute it and/or modify\n  it under the terms of the GNU General Public License as published by\n  the Free Software Foundation; version 2 of the License.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n\n  You should have received a copy of the GNU General Public License\n  along with this program; if not, write to the Free Software\n  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA\n*/\n\n#include \"gtest/gtest.h\"\n#include \"gmock/gmock.h\"\n\n#include <exception>\n\n#define private public\n#include \"mysqlrouter/uri.h\"\n\nusing std::get;\nusing ::testing::StrEq;\nusing ::testing::ContainerEq;\nusing ::testing::IsEmpty;\nusing mysqlrouter::URI;\nusing mysqlrouter::URIError;\nusing mysqlrouter::URIQuery;\nusing mysqlrouter::URIAuthority;\nusing mysqlrouter::URIPath;\nusing mysqlrouter::URIQuery;\n\nusing mysqlrouter::URI;\nusing mysqlrouter::URIError;\nusing mysqlrouter::URIQuery;\nusing mysqlrouter::URIAuthority;\nusing mysqlrouter::URIPath;\nusing mysqlrouter::t_parse_scheme;\nusing mysqlrouter::t_parse_authority;\nusing mysqlrouter::t_parse_path;\nusing mysqlrouter::t_parse_query;\nusing mysqlrouter::t_parse_fragment;\n\nclass URITests: public ::testing::Test {\nprotected:\n  virtual void SetUp() {\n  }\n};\n\nTEST_F(URITests, Constructor)\n{\n  URI u;\n  ASSERT_TRUE(u.scheme.empty());\n  ASSERT_TRUE(u.host.empty());\n  ASSERT_EQ(u.port, 0);\n  ASSERT_TRUE(u.username.empty());\n  ASSERT_TRUE(u.password.empty());\n  ASSERT_TRUE(u.path.empty());\n  ASSERT_TRUE(u.query.empty());\n  ASSERT_TRUE(u.fragment.empty());\n}\n\nTEST_F(URITests, ParseScheme)\n{\n  URI u;\n  ASSERT_THAT(mysqlrouter::t_parse_scheme(\"ham:\"), StrEq(\"ham\"));\n  ASSERT_THAT(mysqlrouter::t_parse_scheme(\"HAM:\"), StrEq(\"ham\"));\n  ASSERT_THAT(mysqlrouter::t_parse_scheme(\"MySQL+Fabric:\"), StrEq(\"mysql+fabric\"));\n  ASSERT_THAT(mysqlrouter::t_parse_scheme(\"MySQL.Fabric:\"), StrEq(\"mysql.fabric\"));\n  ASSERT_THAT(mysqlrouter::t_parse_scheme(\"MySQL-Fabric:\"), StrEq(\"mysql-fabric\"));\n}\n\nTEST_F(URITests, ParseSchemeFail)\n{\n  ASSERT_THROW(mysqlrouter::t_parse_scheme(\"ham\"), URIError);\n  ASSERT_THROW(mysqlrouter::t_parse_scheme(\"ham$$:\"), URIError);\n}\n\nTEST_F(URITests, ParseAuthority)\n{\n  URIAuthority auth;\n\n  auth = mysqlrouter::t_parse_authority(\"ham://spam.example.com\");\n  ASSERT_THAT(get<0>(auth), StrEq(\"spam.example.com\"));\n  ASSERT_EQ(get<1>(auth), 0);\n  ASSERT_TRUE(get<2>(auth).empty());\n  ASSERT_TRUE(get<3>(auth).empty());\n\n  auth = mysqlrouter::t_parse_authority(\"ham://spam.example.com\");\n  ASSERT_THAT(get<0>(auth), StrEq(\"spam.example.com\"));\n\n  auth = mysqlrouter::t_parse_authority(\"ham://scott@spam.example.com/\");\n  ASSERT_THAT(get<0>(auth), StrEq(\"spam.example.com\"));\n  ASSERT_THAT(get<2>(auth), StrEq(\"scott\"));\n  ASSERT_TRUE(get<3>(auth).empty());\n\n  auth = mysqlrouter::t_parse_authority(\"ham://scott:@spam.example.com/\");\n  ASSERT_THAT(get<0>(auth), StrEq(\"spam.example.com\"));\n  ASSERT_THAT(get<2>(auth), StrEq(\"scott\"));\n  ASSERT_TRUE(get<3>(auth).empty());\n\n  auth = mysqlrouter::t_parse_authority(\"ham://:@spam.example.com\");\n  ASSERT_THAT(get<0>(auth), StrEq(\"spam.example.com\"));\n  ASSERT_TRUE(get<2>(auth).empty());\n  ASSERT_TRUE(get<3>(auth).empty());\n\n  auth = mysqlrouter::t_parse_authority(\"ham://scott:tiger@spam.example.com:3306/\");\n  ASSERT_THAT(get<0>(auth), StrEq(\"spam.example.com\"));\n  ASSERT_EQ(get<1>(auth), 3306);\n  ASSERT_THAT(get<2>(auth), StrEq(\"scott\"));\n  ASSERT_THAT(get<3>(auth), StrEq(\"tiger\"));\n\n  auth = mysqlrouter::t_parse_authority(\"ham://spam.example.com:/\");\n  ASSERT_EQ(get<1>(auth), 0);\n  auth = mysqlrouter::t_parse_authority(\"ham://spam.example.com:3306/\");\n  ASSERT_EQ(get<1>(auth), 3306);\n}\n\nTEST_F(URITests, ParseAuthorityFail)\n{\n  ASSERT_THROW(mysqlrouter::t_parse_authority(\"ham\"), URIError);\n  ASSERT_THROW(mysqlrouter::t_parse_authority(\"ham://spam.example.com:999999/\"), URIError);\n  ASSERT_THROW(mysqlrouter::t_parse_authority(\"ham://:3306/\"), URIError);\n}\n\nTEST_F(URITests, ParseAuthorityEmpty)\n{\n  URIAuthority a = mysqlrouter::t_parse_authority(\"ham://\");\n  ASSERT_THAT(get<0>(a), StrEq(\"\"));\n  a = mysqlrouter::t_parse_authority(\"ham:///\");\n  ASSERT_THAT(get<0>(a), StrEq(\"\"));\n}\n\nTEST_F(URITests, ParsePath)\n{\n  URIPath p;\n  p = mysqlrouter::t_parse_path(\"ham://scott:tiger@spam.example.com:3306/the/way/to/go\");\n  ASSERT_THAT(p.at(0), StrEq(\"the\"));\n  ASSERT_THAT(p.at(1), StrEq(\"way\"));\n  ASSERT_THAT(p.at(2), StrEq(\"to\"));\n  ASSERT_THAT(p.at(3), StrEq(\"go\"));\n  ASSERT_THROW(p.at(4), std::out_of_range);\n  p.clear();\n  \n  p = mysqlrouter::t_parse_path(\"ham://scott:tiger@spam.example.com:3306/withslashatend/\");\n  ASSERT_THAT(p.at(0), StrEq(\"withslashatend\"));\n  ASSERT_THROW(p.at(1), std::out_of_range);\n  p.clear();\n  \n  p = mysqlrouter::t_parse_path(\"ham://scott:tiger@spam.example.com:3306/double//slash/\");\n  ASSERT_THAT(p.at(0), StrEq(\"double\"));\n  ASSERT_THAT(p.at(1), StrEq(\"slash\"));\n  ASSERT_THROW(p.at(2), std::out_of_range);\n  p.clear();\n  \n  p = mysqlrouter::t_parse_path(\"file:///path/to/file\");\n  ASSERT_THAT(p.at(2), StrEq(\"file\"));\n  p.clear();\n  p = mysqlrouter::t_parse_path(\"ham://example.com\");\n  ASSERT_THROW(p.at(0), std::out_of_range);\n  p.clear();\n  \n  p = mysqlrouter::t_parse_path(\"ham://example.com/path/to/?key1=val2\");\n  ASSERT_THAT(p.at(0), StrEq(\"path\"));\n  ASSERT_THAT(p.at(1), StrEq(\"to\"));\n  ASSERT_THROW(p.at(2), std::out_of_range);\n  p.clear();\n}\n\nTEST_F(URITests, ParsePathFail)\n{\n  ASSERT_THROW(mysqlrouter::t_parse_path(\"ham\"), URIError);\n}\n\nTEST_F(URITests, ParseQuery)\n{\n  URIQuery q;\n\n  q = mysqlrouter::t_parse_query(\"ham://example.com?key1=val1&key2=val2\", URI::query_delimiter);\n  ASSERT_THAT(q[\"key1\"], StrEq(\"val1\"));\n  ASSERT_THAT(q[\"key2\"], StrEq(\"val2\"));\n  \n  q = mysqlrouter::t_parse_query(\"ham://example.com/path/to/?key1=val1&key2=\", '&');\n  ASSERT_THAT(q[\"key1\"], StrEq(\"val1\"));\n  ASSERT_THAT(q[\"key2\"], StrEq(\"\"));\n  \n  q = mysqlrouter::t_parse_query(\"ham://example.com?key1=val1#foo\");\n  ASSERT_THAT(q[\"key1\"], StrEq(\"val1\"));\n}\n\nTEST_F(URITests, ParseQueryFail)\n{\n  std::string f;\n  \n  f = mysqlrouter::t_parse_fragment(\"ham://example.com?key1=val1#foo\");\n  ASSERT_THAT(f, StrEq(\"foo\"));\n  \n  f = mysqlrouter::t_parse_fragment(\"ham://example.com#foo\");\n  ASSERT_THAT(f, StrEq(\"foo\"));\n  \n  f = mysqlrouter::t_parse_fragment(\"ham://example.com#\");\n  ASSERT_TRUE(f.empty());\n  \n  f = mysqlrouter::t_parse_fragment(\"ham://example.com\");\n  ASSERT_TRUE(f.empty());\n}\n\nTEST_F(URITests, ParseFragmentFail)\n{\n  ASSERT_THROW(mysqlrouter::t_parse_fragment(\"ham\"), URIError);\n}\n\nTEST_F(URITests, ConstructorWithURI)\n{\n  URI u(\"ham://scott:tiger@host.example.com:3306/path/to/sys?key1=val1\");\n  ASSERT_THAT(u.scheme, StrEq(\"ham\"));\n  ASSERT_THAT(u.username, StrEq(\"scott\"));\n  ASSERT_THAT(u.password, StrEq(\"tiger\"));\n  ASSERT_THAT(u.host, StrEq(\"host.example.com\"));\n  ASSERT_EQ(u.port, 3306);\n  ASSERT_THAT(u.path.at(0), StrEq(\"path\"));\n  ASSERT_THAT(u.path.at(1), StrEq(\"to\"));\n  ASSERT_THAT(u.path.at(2), StrEq(\"sys\"));\n  ASSERT_THAT(u.query[\"key1\"], StrEq(\"val1\"));\n}\n\nTEST_F(URITests, ConstructorWithURIFail)\n{\n  ASSERT_THROW(new URI(\"ham$$://scott:tiger@host.example.com:3306/path/to/sys?key1=val1\"), URIError);\n}\n\nTEST_F(URITests, SetURI)\n{\n  URI u(\"ham://scott:tiger@host.example.com:3306/path/to/sys?key1=val1\");\n  u.set_uri(\"spam://spamhost.example.com\");\n  ASSERT_EQ(u.scheme, string(\"spam\"));\n  ASSERT_EQ(u.host, string(\"spamhost.example.com\"));\n  ASSERT_EQ(u.port, 0);\n  ASSERT_EQ(u.username, string());\n  ASSERT_EQ(u.password, string());\n  ASSERT_THAT(u.path, IsEmpty());\n  ASSERT_THAT(u.query, IsEmpty());\n  ASSERT_EQ(u.fragment, string());\n}\n",
            "binary": false,
            "copies": 1,
            "sample_repo_name": "mysql/mysql-router",
            "sample_ref": "refs/heads/2.0",
            "sample_path": "src/router/tests/test_uri.cc",
            "sample_mode": 33188,
            "sample_symlink_target": null
        },
        {
            "id": "8e0ab7a402ed401e4a92a0933d211dada21b4508",
            "size": 903,
            "content": "<?php\n/**\n * Licensed under The GPL-3.0 License\n * For full copyright and license information, please see the LICENSE.txt\n * Redistributions of files must retain the above copyright notice.\n *\n * @since    2.0.0\n * @author   Christopher Castro <chris@quickapps.es>\n * @link     http://www.quickappscms.org\n * @license  http://opensource.org/licenses/gpl-3.0.html GPL-3.0 License\n */\nnamespace User\\Notification\\Message;\n\nuse User\\Model\\Entity\\User;\nuse User\\Notification\\Message\\BaseMessage;\n\n/**\n * Sends instructions for the \"password recovery\" process.\n *\n */\nclass PasswordRequestMessage extends BaseMessage\n{\n\n    /**\n     * {@inheritDoc}\n     */\n    public function send()\n    {\n        $this\n            ->subject(plugin('User')->settings['message_password_recovery_subject'])\n            ->body(plugin('User')->settings['message_password_recovery_body']);\n        return parent::send();\n    }\n}\n",
            "binary": false,
            "copies": 1,
            "sample_repo_name": "quickapps/cms",
            "sample_ref": "refs/heads/2.0",
            "sample_path": "plugins/User/src/Notification/Message/PasswordRequestMessage.php",
            "sample_mode": 33188,
            "sample_symlink_target": null
        },
        {
            "id": "9281ba3801cf1a02af6ea13bebdc19a41d48b463",
            "size": 1444,
            "content": "<?php\n/**\n * Licensed under The GPL-3.0 License\n * For full copyright and license information, please see the LICENSE.txt\n * Redistributions of files must retain the above copyright notice.\n *\n * @since    2.0.0\n * @author   Christopher Castro <chris@quickapps.es>\n * @link     http://www.quickappscms.org\n * @license  http://opensource.org/licenses/gpl-3.0.html GPL-3.0 License\n */\n\n$skins = [\n    'black' => 'Black',\n    'black-light' => 'Black Light',\n    'blue' => 'Blue',\n    'blue-light' => 'Blue Light',\n    'green' => 'Green',\n    'green-light' => 'Green Light',\n    'purple' => 'Purple',\n    'purple-light' => 'Purple Light',\n    'red' => 'Red',\n    'red-light' => 'Red Light',\n    'yellow' => 'Yellow',\n    'yellow-light' => 'Yellow Light',\n];\n?>\n\n<fieldset>\n    <legend><?php echo __d('backend_theme', 'Layout Options'); ?></legend>\n    <?php echo $this->Form->input('fixed_layout', ['type' => 'checkbox', 'label' => __d('backend_theme', 'Fixed Layout')]); ?>\n    <?php echo $this->Form->input('boxed_layout', ['type' => 'checkbox', 'label' => __d('backend_theme', 'Boxed Layout')]); ?>\n    <?php echo $this->Form->input('collapsed_sidebar', ['type' => 'checkbox', 'label' => __d('backend_theme', 'Collapsed Sidebar')]); ?>\n</fieldset>\n\n<fieldset>\n    <legend><?php echo __d('backend_theme', 'Skins'); ?></legend>\n    <?php echo $this->Form->input('skin', ['type' => 'select', 'options' => $skins, 'label' => false]); ?>\n</fieldset>\n",
            "binary": false,
            "copies": 1,
            "sample_repo_name": "quickapps/cms",
            "sample_ref": "refs/heads/2.0",
            "sample_path": "plugins/BackendTheme/src/Template/Element/settings.ctp",
            "sample_mode": 33188,
            "sample_symlink_target": null
        }
    ]
}